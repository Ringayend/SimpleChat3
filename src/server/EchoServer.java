// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package server;import java.io.*;import java.util.Observable;import java.util.Observer;import common.ChatIF;import ocsf.client.ObservableClient;import ocsf.server.*;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {	// Class variables *************************************************	ChatIF serverUI;	ObservableOriginatorServer oos;		// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port	 *            The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {				this.serverUI = serverUI;		this.oos = new ObservableOriginatorServer(port);		this.oos.addObserver(this);	}	// Instance methods ************************************************	public void acceptServer() 	  {	    try	    {	      BufferedReader fromConsole = 	        new BufferedReader(new InputStreamReader(System.in));	      String message;	      //this.sendToAllClients("Server MSG >" + message);	      while (true) 	      {	        message = fromConsole.readLine();	        String [] splitMessage = message.split(" ");			switch(splitMessage[0]) {				case "#quit" :					// send to All clients Logout					this.oos.sendToAllClients("#quit");					//close all					this.oos.close();					// system exit					System.exit(0);					break;				case "#stop":					this.oos.stopListening();						break;				case "#close" :					this.oos.close();					break;				case "#setport":					this.oos.setPort(Integer.parseInt(splitMessage[1]));					break;				case "#start":					this.oos.listen();					break;				case "#getport":					serverUI.display("" + this.oos.getPort());					break;				default:					this.oos.sendToAllClients("Server MSG > " + message);			}	      }	    } 	    catch (Exception ex) 	    {	    	serverUI.display("Unexpected error while reading from Server console!");	    }	  }	/**	 * This method handles any messages received from the client.	 *	 * @param msg	 *            The message received from the client.	 * @param client	 *            The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {				// Si le client cherche à s'identifier		if (((String)msg).startsWith("#login")) {			//Vérification qu'il ne s'identifie pas pour la deuxième fois			if (client.getInfo("id") != null) {				try {					client.sendToClient("Error, already login !");				} catch (IOException e) {					e.printStackTrace();				}			} else {				String [] splitMessage = ((String)msg).split(" ");				client.setInfo("id", splitMessage[1]);				serverUI.display("Client " + splitMessage[1] + " is connected");				this.oos.sendToAllClients("Client " + splitMessage[1] + " is connected");			}					// Si le client veut communiquer		} else {			//on vérifie qu'il se soit déjà identifié			if (client.getInfo("id") == null) {				try {					client.sendToClient("Error, you have to log in first !");					client.close();				} catch (IOException e) {					e.printStackTrace();				}			} else {				String id = (String) client.getInfo("id");				serverUI.display("Message received: " + msg + " from " + id);				this.oos.sendToAllClients(msg);			}		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		serverUI.display("Server listening for connections on port " + this.oos.getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server	 * stops listening for connections.	 */	protected void serverStopped() {		serverUI.display("Server has stopped listening for connections.");	}		protected void serverClosed() {		serverUI.display("Server has stopped listening for connections.");	}	// Class methods ***************************************************	 protected void clientConnected(ConnectionToClient client) {		 serverUI.display("Client connected");	 }	 	 synchronized protected void clientDisconnected(ConnectionToClient client) {		 serverUI.display("Client disconnected");	 }	@Override	public void update(Observable o, Object arg) {			OriginatorMessage om = (OriginatorMessage) arg;			String msg = om.getMessage().toString();			//ConnectionToClient client = om.getOriginator();						if (msg.contains(ObservableOriginatorServer.CLIENT_EXCEPTION)){ 				this.handleMessageFromClient(msg, om.getOriginator());			} else if (msg.contains(ObservableOriginatorServer.CLIENT_CONNECTED)) {				this.clientConnected(om.getOriginator());			} else if (msg.contains(ObservableOriginatorServer.LISTENING_EXCEPTION)){ 				this.serverUI.display(msg.toString());			} else if (msg.contains(ObservableOriginatorServer.CLIENT_DISCONNECTED)) {				this.clientDisconnected(om.getOriginator());			} else if (msg.contains(ObservableOriginatorServer.SERVER_CLOSED)) {				this.serverUI.display(msg.toString());			} else if (msg.contains(ObservableOriginatorServer.SERVER_STARTED)) {				this.serverStarted();			} else if (msg.contains(ObservableOriginatorServer.SERVER_STOPPED)) {				this.serverStopped();			} else {				this.handleMessageFromClient(msg, om.getOriginator());			}					}					public void listen() throws IOException {		this.oos.listen();			} 	  }// End of EchoServer class